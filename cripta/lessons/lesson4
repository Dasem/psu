Совокупность всех ключей в системе - ключевая информация

Управление ключами включает в себя:
	
	1. Генерацию ключей
	2. Накопление / хранение ключей
	3. Распределение ключей


В симметричной криптосистеме длина ключа меньше, чем в ассиметричной

В ассиметричной доп. условия, как правило (например ключ - простое число или ф-я эйлера от произведения 2-х простых чисел)

Используются природные генераторы случайных чисел для генерации ключей, например "белый шум"

Для криптосистем среднего уровня защищённости подходит генерация ключей с помощью генератора псевдо-случайных чисел (Один из стандартов - ANSI X 9.17)

Трипл дес:
Ri = Ek(Ei(Ti)+Vi)
V(i+1) = Ek(Ek(Ti)+Ri)


--- Накопление/Хранение

	- Хранение
	- Учёт
	- Удаление

Иерархия ключей

	- Двухуровневая иерархия
	kk/kd

	- Трёхуровневая иерархия
	Есть ключи шифрования данных
	Ключи шифрования ключей
	Шифрование всех ключей шифрования (lol)

Любая информация о ключах должна быть зашифрована

Мастер-ключи как правило хранят на физических носителях, отделённых от автоматизированной системы, в которых используются эти ключи

Обновление ключей
	
	В криптосистемах с повышенной защитой рекомендуют менять ключи ежедневно

--- Распределение ключей

	- Децентрализованная система хранения ключей
	- Для обмена ключей криптосистема с открытым ключом

Ева - злоумышленник!!!!!!

Может перехватить ключи K1, K2 и определить Da и Db с помощью дискретного логарифмирования, соответственно полчив ключ k

Диффи - Хельман уязвим от атаки MitM


....... Тут скипнута какая-та часть лекции про керберос (вроде не про тот, что в винде, а просто типа от слова цербер)


Решение проблемы аутентификации
	
	1. Механизм запроса/ответа
	Пользователь генерирует случайное число, шифрует его и передаёт другому.
	Другой пользователь расшифровывает, модифицирует по какому-то правилу, шифрует и отправляет обратно
	Если первый получил ожидаемое видоизменённое число, то считает что установил связь с подлинным человеком

	2. Механизм меток времени
	К сообщению теперь добавляется не случайное число, а метку времени, она шифруется и отправляется.
	На другом конце она проверяется, добавляется своя, шифруется и опять посылается
	
	Недостатки:
	Должны быть синхронизованы часы


Нидхем-Шредер (Этот протокол):

1. Алиса отправляет на сервер инфу о том, что она Алиса и хочет связаться с Бобом, а так же случайное число
2. Сервер (Trent (посредник)) отдаёт алисе вот что: Ea(Ra, B, K, Ekb(K, A)), т.е. вместе со всем отдаёт сеансовый ключ, зашифрованный секретным ключом Боба
3. Теперь Алиса обладает всей вот этой информацией, но она посылает соответственно Бобу ключ и свой идентификатор Ekb(K,A)
4. Боб делает чек Алису на Алису: Ek(Rb) посылает Алисе
5. А алиса делает Ek(Rb-1) и высылает Бобу
6. Боб, убеждаясь что ему вернулось случайное число ещё и уменьшенное на единицу, понимает что Алиса это Алиса

----------- Хз что это такое

Алиса вступает в рейдмод и шифрует: {I, A, B, Eka(Ra, I, A, B)}

Боб берёт идентификатор, то что нашифровала Алиса и делает свою добавку: {I, A, B, Eka(Ra, I, A, B), Ekb(Rb, I, A, B)}. После отправляет это доверенному центру (центру распределения ключей)

Собсна этот центр (сервер(treat(посредник))) Берёт идентификаторы, сеансовый ключ который он создаст и делает вот что: {I, Eka(Ra, K), Ekb(Rb, K)}. Отсылает это Бобу.

Боб убеждается в том, что Rb не изменилось (получил от сервера) и получил сеансовый ключ.

Боб высылает номер сессии, ну и понятно что он высылает {I, Eka(Ra, K)}. Таким образом боб видит, что номер сеанса не изменился пока.

----------- Конец хз что это такое

Распределение ключей для Ассиметричной криптосистемы естесственно у нас отличается, причём принципиально. Для неё надо хранить открытые ключи, а закрытые будут знать только их владельцы.

Наивный подход к распределению: держать открытые ключи в опубликованных источниках

Опять проблемы:
	1. Кто-то за Алису может опубликовать её ключ
	2. Даже если Алиса опубликовала свой ключ, ей может кто-то написать от имени, например, Боба (Проблема аутентификации сторон)

Для того чтобы хранить и распределять эти ключи формируются центры доверия

На основе стандартов создают инфраструктуру открытых ключей
